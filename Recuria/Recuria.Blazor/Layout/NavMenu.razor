@using MudBlazor
@inject Recuria.Client.IRecuriaApiClient Api
@inject Recuria.Blazor.Services.AuthState Auth
@inject NavigationManager Nav
@implements IDisposable



<MudNavMenu Class="pa-2">
    @if(_isAuthenticated)
    {
        <MudNavLink Href="/" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Home">Home</MudNavLink>
        <MudNavLink Href="/dashboard" Icon="@Icons.Material.Filled.Dashboard">Dashboard</MudNavLink>
        <MudNavLink Href="/invoices" Icon="@Icons.Material.Filled.ReceiptLong">Invoices</MudNavLink>
        <MudNavLink Href="/subscriptions" Icon="@Icons.Material.Filled.Subscriptions">Subscriptions</MudNavLink>
        <MudNavLink Href="/users" Icon="@Icons.Material.Filled.Group">Users</MudNavLink>
        <MudNavLink Href="/settings" Icon="@Icons.Material.Filled.Settings">Settings</MudNavLink>
        <MudButton Variant="Variant.Text" Color="Color.Error" OnClick="Logout">Logout</MudButton>
    }
    else
    {
        <MudNavLink Href="/login" Icon="@Icons.Material.Filled.Login">Login</MudNavLink>
    }

    @if (_canSeeOps)
    {
        <MudNavLink Href="/ops" Icon="@Icons.Material.Filled.AdminPanelSettings">Ops</MudNavLink>
    }
</MudNavMenu>

    @code {
    private bool _canSeeOps = false;
    private bool _isAuthenticated;

    protected override async Task OnInitializedAsync()
    {
        Auth.AuthStateChanged += HandleAuthStateChanged;
        await RefreshAuthUiAsync();
    }

    private async void HandleAuthStateChanged()
    {
        await RefreshAuthUiAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RefreshAuthUiAsync()
    {
        _isAuthenticated = await Auth.IsAuthenticatedAsync();

        if (!_isAuthenticated)
        {
            _canSeeOps = false;
            return;
        }

        try
        {
            var who = await Api.WhoamiAsync();
            var role = who?.Role?.Trim();
            _canSeeOps = role is "Owner" or "Admin";
        }
        catch
        {
            _canSeeOps = false;
            _isAuthenticated = false;
            await Auth.ClearAsync();
        }
    }

    public void Dispose()
    {
        Auth.AuthStateChanged -= HandleAuthStateChanged;
    }

    private async Task Logout()
    {
        try
        {
            await Api.LogoutAsync();
        }
        catch
        {
            // Ignore API logout failures; still clear local session.
        }

        await Auth.ClearAsync();
        Nav.NavigateTo("/login", forceLoad: false);
    }    
}
